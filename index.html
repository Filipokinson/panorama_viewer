<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Просмотр панорам</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
        }
        body {
            overflow: hidden;
            background: #000;
            cursor: grab;
            touch-action: none;
        }
        body.dragging {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        function startPanorama() {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                10000
            );
            
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                precision: 'highp'
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const textureLoader = new THREE.TextureLoader();
            
            textureLoader.load('./pup.jpg', function(texture) {
                const geometry = new THREE.SphereGeometry(500, 64, 32);
                geometry.scale(-1, 1, 1);
                
                const material = new THREE.MeshBasicMaterial({ map: texture });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                
                console.log('Панорама загружена успешно');
            }, 
            function(progressEvent) {
                console.log('Загрузка: ' + (progressEvent.loaded / progressEvent.total * 100) + '%');
            },
            function(error) {
                console.error('Ошибка загрузки панорамы:', error);
            });

            let isDown = false;
            let previousPosition = { x: 0, y: 0 };
            
            let velocity = { x: 0, y: 0 };
            const friction = 0.95;
            const sensitivity = 0.005;

            document.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    isDown = true;
                    velocity = { x: 0, y: 0 };
                    previousPosition = { x: e.clientX, y: e.clientY };
                    document.body.classList.add('dragging');
                }
            });

            document.addEventListener('mouseup', (e) => {
                isDown = false;
                document.body.classList.remove('dragging');
            });

            document.addEventListener('mousemove', (e) => {
                if (isDown) {
                    const deltaX = e.clientX - previousPosition.x;
                    const deltaY = e.clientY - previousPosition.y;
                    
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y += deltaX * sensitivity;
                    camera.rotation.x += deltaY * sensitivity;
                    
                    const maxAngle = Math.PI / 2;
                    camera.rotation.x = Math.max(-maxAngle, Math.min(maxAngle, camera.rotation.x));
                    
                    velocity.x = deltaX * sensitivity;
                    velocity.y = deltaY * sensitivity;
                    
                    previousPosition = { x: e.clientX, y: e.clientY };
                }
            });

            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDown = true;
                    velocity = { x: 0, y: 0 };
                    const touch = e.touches[0];
                    previousPosition = { x: touch.clientX, y: touch.clientY };
                    document.body.classList.add('dragging');
                }
            });

            document.addEventListener('touchend', (e) => {
                isDown = false;
                document.body.classList.remove('dragging');
            });

            document.addEventListener('touchmove', (e) => {
                if (isDown && e.touches.length === 1) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - previousPosition.x;
                    const deltaY = touch.clientY - previousPosition.y;
                    
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y += deltaX * sensitivity;
                    camera.rotation.x += deltaY * sensitivity;
                    
                    const maxAngle = Math.PI / 2;
                    camera.rotation.x = Math.max(-maxAngle, Math.min(maxAngle, camera.rotation.x));
                    
                    velocity.x = deltaX * sensitivity;
                    velocity.y = deltaY * sensitivity;
                    
                    previousPosition = { x: touch.clientX, y: touch.clientY };
                    
                    e.preventDefault();
                }
            });

            document.addEventListener('selectstart', (e) => {
                if (isDown) {
                    e.preventDefault();
                }
            });

            function animate() {
                requestAnimationFrame(animate);
                
                if (!isDown && (Math.abs(velocity.x) > 0.0001 || Math.abs(velocity.y) > 0.0001)) {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y += velocity.x;
                    camera.rotation.x += velocity.y;
                    
                    const maxAngle = Math.PI / 2;
                    camera.rotation.x = Math.max(-maxAngle, Math.min(maxAngle, camera.rotation.x));
                    
                    velocity.x *= friction;
                    velocity.y *= friction;
                }
                
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function checkTHREE() {
            if (typeof THREE !== 'undefined') {
                startPanorama();
            } else {
                setTimeout(checkTHREE, 100);
            }
        }
        
        checkTHREE();
    </script>
</body>
</html>
